<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Happy Birthday Animation</title>

<link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">

<style>
  :root {
    /* chống giật khi thanh URL mobile ẩn/hiện */
    height: 100%;
  }
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
    touch-action: manipulation;            /* giảm double-tap zoom */
    overscroll-behavior: contain;
  }
  /* Canvas full màn hình */
  #canvas {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    display: block;
  }

  /* ===== Overlay xoay ngang (chỉ hiện khi dọc) ===== */
  #rotate-screen {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    background: #000;
    display: none; /* ẩn mặc định, JS sẽ bật khi dọc */
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 10000;
    color: #fff;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    text-align: center;
    gap: 16px;
  }
  /* icon điện thoại xoay */
  .phone-icon {
    width: 88px;
    height: 130px;
    border: 4px solid #fff;
    border-radius: 18px;
    position: relative;
    animation: rotatePhone 1.6s infinite ease-in-out;
  }
  .phone-icon::before {
    content: "";
    position: absolute;
    top: 6px; left: 50%;
    transform: translateX(-50%);
    width: 28px; height: 6px;
    background: #fff; border-radius: 3px;
  }
  @keyframes rotatePhone {
    0% { transform: rotate(0deg) }
    50% { transform: rotate(90deg) }
    100% { transform: rotate(0deg) }
  }

  /* ===== Màn hình loading ===== */
  #loading-screen {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    background: #000;
    display: none;
    place-items: center;
    z-index: 9999;
  }
  .loading-wrap {
    display: flex; flex-direction: column; align-items: center;
  }
  .spinner {
    border: 5px solid transparent;
    border-top: 5px solid #fff;
    border-radius: 50%;
    width: 42px; height: 42px;
    animation: spin 1s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg) } }
  .loading-text {
    margin-top: 14px;
    font-size: 22px;
    font-family: 'Pacifico', cursive;
    color: #fff;
  }
</style>
</head>
<body>

<!-- Overlay xoay ngang (hiện khi dọc) -->
<div id="rotate-screen" aria-hidden="true">
  <div class="phone-icon"></div>
  <div>Hãy xoay ngang màn hình</div>
</div>

<!-- Loading -->
<div id="loading-screen" aria-hidden="true">
  <div class="loading-wrap">
    <div class="spinner"></div>
    <div class="loading-text">Đang tải...</div>
  </div>
</div>

<canvas id="canvas"></canvas>

<script>
/* ===== Ngăn pinch-zoom / double-tap zoom ===== */
document.addEventListener('gesturestart', e => e.preventDefault(), {passive:false});
document.addEventListener('gesturechange', e => e.preventDefault(), {passive:false});
document.addEventListener('gestureend', e => e.preventDefault(), {passive:false});
let lastTouchEnd = 0;
document.addEventListener('touchend', e => {
  const now = Date.now();
  if (now - lastTouchEnd <= 300) e.preventDefault(); // chặn double-tap
  lastTouchEnd = now;
}, {passive:false});
document.addEventListener('wheel', e => {
  if (e.ctrlKey) e.preventDefault(); // chặn Ctrl + wheel zoom
}, {passive:false});

/* ===== Canvas + DPI scale ===== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });

function setCanvasSize() {
  const dpr = Math.min(window.devicePixelRatio || 1, 2); // cap 2 để không quá nặng
  const w = Math.floor(window.innerWidth);
  const h = Math.floor(window.innerHeight);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // dùng toạ độ CSS pixels
}
setCanvasSize();
window.addEventListener('resize', () => {
  setCanvasSize();
  resetRain();
  if (countdownStarted) particles = createParticlesForText(messages[msgIndex]); // re-layout theo size mới
});

/* ===== Mưa chữ HAPPYBIRTHDAY (auto scale) ===== */
const letters = "HAPPYBIRTHDAY".split("");
let rainFontSize = 22, columns = 0, drops = [];

function resetRain() {
  // scale theo chiều nhỏ hơn để ổn định
  const base = Math.min(window.innerWidth, window.innerHeight);
  rainFontSize = Math.max(14, Math.round(base / 28));         // auto scale
  columns = Math.max(10, Math.floor(window.innerWidth / rainFontSize));
  drops = Array(columns).fill(0);
}
resetRain();

function drawRain() {
  ctx.fillStyle = "rgba(0,0,0,0.08)";
  ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

  ctx.font = rainFontSize + "px monospace";
  for (let i = 0; i < columns; i++) {
    ctx.fillStyle = (i & 1) === 0 ? "pink" : "lightpink";
    const text = letters[(Math.random() * letters.length) | 0];
    ctx.fillText(text, i * rainFontSize, drops[i] * rainFontSize);
    if (drops[i] * rainFontSize > window.innerHeight && Math.random() > 0.975) drops[i] = 0;
    drops[i]++;
  }
}

/* ===== Particles + Countdown (auto scale) ===== */
class Particle {
  constructor(x, y, tx, ty, size) {
    this.x = x; this.y = y;
    this.tx = tx; this.ty = ty;
    this.size = size;
    this.color = "hotpink";
    this.vx = (Math.random() - 0.5) * 3.5;
    this.vy = (Math.random() - 0.5) * 3.5;
    this.alpha = Math.random();
    this.scale = 0;
    this.twinkleSpeed = 0.035 + Math.random() * 0.04;
  }
  update(forming, t) {
    if (forming) {
      this.x += (this.tx - this.x) * 0.12;
      this.y += (this.ty - this.y) * 0.12;
      this.scale += (1 - this.scale) * 0.06;
    } else {
      this.x += this.vx;
      this.y += this.vy;
      this.scale *= 0.97;
    }
    // dùng chung timestamp t để giảm tính toán
    this.alpha = 0.5 + 0.5 * Math.sin(t * this.twinkleSpeed);
  }
  draw() {
    ctx.globalAlpha = this.alpha;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * this.scale, 0, Math.PI * 2);
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function getFontSizeForText(text) {
  const minSide = Math.min(window.innerWidth, window.innerHeight);
  // scale theo độ dài chuỗi
  if (text.length <= 2) return Math.floor(minSide * 0.50);
  if (text.length <= 4) return Math.floor(minSide * 0.30);
  if (text.length <= 8) return Math.floor(minSide * 0.22);
  return Math.floor(minSide * 0.18);
}

function createParticlesForText(text) {
  const temp = document.createElement('canvas');
  const tctx = temp.getContext('2d');
  temp.width = window.innerWidth;
  temp.height = window.innerHeight;

  const f = getFontSizeForText(text);
  tctx.fillStyle = "#fff";
  tctx.textAlign = "center";
  tctx.textBaseline = "middle";
  tctx.font = "bold " + f + "px Arial";
  tctx.fillText(text, temp.width / 2, temp.height / 2);

  const img = tctx.getImageData(0, 0, temp.width, temp.height).data;

  // khoảng cách mẫu theo font size để giữ mật độ ổn định trên màn nhỏ
  const gap = Math.max(3, Math.min(8, Math.floor(f / 28)));
  const dotSize = Math.max(1.3, Math.min(2.6, f / 120));

  const arr = [];
  for (let y = 0; y < temp.height; y += gap) {
    for (let x = 0; x < temp.width; x += gap) {
      const a = img[(y * temp.width + x) * 4 + 3];
      if (a > 128) {
        arr.push(new Particle(
          Math.random() * temp.width,
          Math.random() * temp.height,
          x, y,
          dotSize
        ));
      }
    }
  }
  return arr;
}

const messages = ["3", "2", "1", "HAPPY", "BIRTHDAY", "TO", "YOU"];
let msgIndex = 0;
let particles = [];
let forming = true;
let switchTime = Date.now();
let countdownStarted = false;

function animate() {
  drawRain();

  if (countdownStarted) {
    const t = performance.now() * 0.001; // timestamp dùng chung
    for (let i = 0; i < particles.length; i++) {
      particles[i].update(forming, t);
      particles[i].draw();
    }

    if (Date.now() - switchTime > 2000) {
      if (forming) {
        forming = false;
        switchTime = Date.now();
      } else {
        msgIndex++;
        if (msgIndex < messages.length) {
          particles = createParticlesForText(messages[msgIndex]);
          forming = true;
          switchTime = Date.now();
        }
      }
    }
  }
  requestAnimationFrame(animate);
}

/* ===== Hiển thị overlay khi dọc, loading khi ngang ===== */
const rotateEl = document.getElementById('rotate-screen');
const loadingEl = document.getElementById('loading-screen');

function isPortrait() {
  // dùng matchMedia nếu có, fallback theo width/height
  return (window.matchMedia && window.matchMedia('(orientation: portrait)').matches)
         || window.innerHeight > window.innerWidth;
}

function handleOrientationFlow() {
  if (isPortrait()) {
    // Đang dọc: chỉ hiện overlay xoay ngang
    rotateEl.style.display = 'flex';
    loadingEl.style.display = 'none';
    countdownStarted = false;
  } else {
    // Đang ngang: ẩn overlay, chạy loading -> countdown
    rotateEl.style.display = 'none';
    loadingEl.style.display = 'grid';

    // reset state trước khi start
    msgIndex = 0;
    forming = true;
    particles = [];

    // loading 3s, chờ 1.5s rồi bắt đầu
    setTimeout(() => {
      loadingEl.style.display = 'none';
      setTimeout(() => {
        particles = createParticlesForText(messages[msgIndex]);
        countdownStarted = true;
        switchTime = Date.now();
      }, 1500);
    }, 3000);
  }
}

window.addEventListener('resize', handleOrientationFlow);
window.addEventListener('orientationchange', handleOrientationFlow);
window.addEventListener('load', () => {
  setCanvasSize();
  resetRain();
  handleOrientationFlow();
  animate();
});
</script>

</body>
</html>
